## Virtual ISA Description

<!--- NOTE: this file is PARTIALLY autogenerated via: Base/opcode_tab.py documentation --->

The instructions are modeled after a generic three register RISC ISA, 
with an infinite number of registers, e.g.
```
sub r0 r1 r2        # r0 = r1 - r2
sub r0 0x666 r2     # r0 = 0x666 - r2
sub r0 r1 0x666     # r0 = r1 - 0x666 
```

Many operands can be either registers or constants (subject to typing constraints).

The opcodes are overloaded and the type of the operands determines the actual behavior.
For example `div` can be used with signed and unsigned integers or even floating point 
operands.

Function calls are modelled with instruction sequences using 
`poparg` and `pusharg` instructions to pass parameters and return results.

The `cmpXX` opcode is an oddball accessing 5 registers.

Examples programs can be found in [../TestData](../TestData)

### Typing 

Registers and constants are typed. Where a type is a tuple of `flavor` and `width`.

Currently, the `width` is one of 8, 16, 32, 64 bits and the `flavor` is one of:
* **U** unsigned int (wrap around - no trap on overflow)
* **S** signed int (2's complement, wrap around - no trap on overflow)
* **F** floating point (ieee formats)
* **A** data address 
* **C** code address (only function but not bbl addresses are currently exposed)

Registers must be declared before use so that their type is known.
The declaration can happen in one of two ways: 
1. with  the `.reg` directive 
2. with a `colon-suffix` by the first instruction writing to it.

```
.reg F32 [a b c]   # declares registers a, b, c to be 32 bit wide and of flavor F
add a b c
```
is equivalent to
```
.reg F32 [b c]
add a:F32 b c
```

A constant must also be typed using the `colon-suffix` unless the type can be deduced
from the other operands which is usually the case.

```
.reg F32 [a b]
add a b 1.0:F32
```
is equivalent to 

```
.reg F32 [a b]
add a b 1.0
```

For constant that are stored (via `st`) or pushed (via `pusharg`) the types
cannot be deduced and must always be provided:

```
.reg A32 [a]
...
st a 16 = 1.0:f32   # stores a 32 bit wide floating point constant
st a 16 = 32:U8     # stores a 8 bit wide integer constant
st a 16 = 0:A64     # stores a 64 bit wide null pointer
push 0:C64          # pushes  a 64 bit wide code null pointer
```


* The type of operands must agree for most instructions
* The modified register, if any, is always the first operand.
* Target architectures may not support all width and types
* New types, e.g. for vector and SIMD operations, may be added in the future.


### Addressing Modes

Load and store instructions have one addressing mode: `base + offset`

The base is usually an address register but may also be a global memory
address or a location within the current stack frame.
The offset can be a register or a constant.

### Address Arithmetic

The `lea` (load effective address) family of opcodes allows for the 
addition of integers to addresses. This is only possible for data addresses
not code addresses.

Limited address arithmetic helps the optimizer to better reason about memory
conflicts. It can be worked around via bitcasts between 
integers of addresses of the same size.

###  How to read the Opcode descriptions below

```
OPCODE OPERAND_1 [constraint_1]  ...  OPERAND_n [constraint_n] 
```

The `constraint` describes the kind of the operand as shown below:

| Operand Kind | Description |
| ----- | ---- |
| REG | Register |
| CONST | Constant |
| REG/CONST | Register or Constant |
| FUN | Function or Function Signature|
| BBL | Basic Block|
| JTB | Jump Table | 
| MEM | Global Memory Location |
| STK | Stack Location | 

For REG and CONST operands there is an additional  type constraint (seperated by a  ':'):

| Type Constraint | Description |
| ----- | ---- |
| ANY | no contraints |
| UINT |  flavor must be U |
| INT |  flavor must be one of S, U |
| NUM | flavor must be one of F, S, U |
| ADDR | flavor must be A |
| ADDR_NUM | flavor must be A, F, S, U |
| CODE | flavor must be C |
| OFFSET | TBD |
| SAME_AS_PREV | type must be same as previous REG or CONST | 


All kinds except for `CONST` must match the following regex: `[%_$a-zA-Z][%_$a-zA-Z0-9]*`

 `$` should be used for name-space management and 
 `%` to avoid name clashes with the original source language
   

<!--- @AUTOGEN-START@ --->
## Basic ALU

#### [10] add *dst* <sub>[REG:NUM]</sub> = *src1* <sub>[REG/CONST:SAME_AS_PREV]</sub> *src2* <sub>[REG/CONST:SAME_AS_PREV]</sub>
Addition: dst := src1 + src2

#### [11] sub *dst* <sub>[REG:NUM]</sub> = *src1* <sub>[REG/CONST:SAME_AS_PREV]</sub> *src2* <sub>[REG/CONST:SAME_AS_PREV]</sub>
Subtraction: dst := src1 - src2

#### [12] mul *dst* <sub>[REG:NUM]</sub> = *src1* <sub>[REG/CONST:SAME_AS_PREV]</sub> *src2* <sub>[REG/CONST:SAME_AS_PREV]</sub>
Multiplication: dst := src1 \* src2

#### [13] div *dst* <sub>[REG:NUM]</sub> = *src1* <sub>[REG/CONST:SAME_AS_PREV]</sub> *src2* <sub>[REG/CONST:SAME_AS_PREV]</sub>
Division: dst := src1 / src2 
             
             Some day the operation might be more strictly defined as: 
             
             dst := 0 if src2 == 0 else src1 / src2

#### [14] rem *dst* <sub>[REG:NUM]</sub> = *src1* <sub>[REG/CONST:SAME_AS_PREV]</sub> *src2* <sub>[REG/CONST:SAME_AS_PREV]</sub>
Modulo: dst := a % b
              
              Some day the sign of the result might be more strictly defined.

#### [18] xor *dst* <sub>[REG:INT]</sub> = *src1* <sub>[REG/CONST:SAME_AS_PREV]</sub> *src2* <sub>[REG/CONST:SAME_AS_PREV]</sub>
Bitwise exclusive or: dst := src1 ^ src2

#### [19] and *dst* <sub>[REG:INT]</sub> = *src1* <sub>[REG/CONST:SAME_AS_PREV]</sub> *src2* <sub>[REG/CONST:SAME_AS_PREV]</sub>
Bitwise and: dst := src1 & src2

#### [1a] or *dst* <sub>[REG:INT]</sub> = *src1* <sub>[REG/CONST:SAME_AS_PREV]</sub> *src2* <sub>[REG/CONST:SAME_AS_PREV]</sub>
Bitwise or: dst := src1 | src2

#### [1b] shl *dst* <sub>[REG:INT]</sub> = *src1* <sub>[REG/CONST:SAME_AS_PREV]</sub> *src2* <sub>[REG/CONST:SAME_AS_PREV]</sub>
Shift left: dst := src1 << src2
              
              Some day the operation might more strictly defined as:
             
             dst: = src1 << (src2 mod bitwidth(src2))

#### [1c] shr *dst* <sub>[REG:INT]</sub> = *src1* <sub>[REG/CONST:SAME_AS_PREV]</sub> *src2* <sub>[REG/CONST:SAME_AS_PREV]</sub>
Shift right: dst := src1 >> src2
             
             Some day the operation might more strictly defined as:
             
             dst: = src1 >> (src2 mod bitwidth(src2))

#### [1d] rotl *dst* <sub>[REG:INT]</sub> = *src1* <sub>[REG/CONST:SAME_AS_PREV]</sub> *src2* <sub>[REG/CONST:SAME_AS_PREV]</sub>
Rotation Left

## Conditional Branches

#### [20] beq *op1* <sub>[REG/CONST:ANY]</sub> *op2* <sub>[REG/CONST:SAME_AS_PREV]</sub> *target_bbl* <sub>[BBL]</sub>
Conditional branch if equal.

#### [21] bne *op1* <sub>[REG/CONST:ANY]</sub> *op2* <sub>[REG/CONST:SAME_AS_PREV]</sub> *target_bbl* <sub>[BBL]</sub>
Conditional branch if not equal.

#### [22] blt *op1* <sub>[REG/CONST:ADDR_NUM]</sub> *op2* <sub>[REG/CONST:SAME_AS_PREV]</sub> *target_bbl* <sub>[BBL]</sub>
Conditional branch if greater than.

#### [23] ble *op1* <sub>[REG/CONST:ADDR_NUM]</sub> *op2* <sub>[REG/CONST:SAME_AS_PREV]</sub> *target_bbl* <sub>[BBL]</sub>
Conditional branch if less or equal.

## Other Control Flow

#### [28] switch *index* <sub>[REG:UINT]</sub> *table* <sub>[JTB]</sub>
Multi target computed jump. 
                
                The register argument must be less than the jtb `size`.
                
                The jtb symbol must have been previously defined with the `.jtb` directive.
                

#### [29] bra *target_bbl* <sub>[BBL]</sub>
Unconditional branch.

#### [2a] ret 
Return from subroutine.

#### [2b] bsr *target_fun* <sub>[FUN]</sub>
Branch to subroutine fun

#### [2c] jsr *target_fun_addr* <sub>[REG:CODE]</sub> *target_fun_sig* <sub>[FUN]</sub>
Jump indirectly to subroutine through register (fun describes the signature). The signature must have been previously defined with the `.fun` directive.

#### [2d] syscall *target_fun_sig* <sub>[FUN]</sub> *syscall_no* <sub>[CONST:UINT]</sub>
Syscall to `syscall_no`. (fun describes the signature). The signature must have been previously defined with the `.fun` directive.

#### [2e] trap 
Abort program.

## Move/Conversion

#### [30] pusharg *src* <sub>[REG/CONST:ANY]</sub>
push call or return arg - must immediately precede bsr/jsr or ret

#### [31] poparg *dst* <sub>[REG:ANY]</sub> =
pop call or return arg - must immediately follow fun entry or bsr/jsr

#### [32] conv *dst* <sub>[REG:NUM]</sub> = *src* <sub>[REG/CONST:NUM]</sub>
Conversion of numerical regs which do not have to be of same size. Bits may change. Note: Use mov if both regs have the same kind.

#### [33] bitcast *dst* <sub>[REG:ANY]</sub> = *src* <sub>[REG/CONST:SAME_SIZE_AS_PREV]</sub>
Cast between regs of same size. Bits will be re-interpreted but do not change. This can be used to manipulated addresses im unusual ways.

#### [34] mov *dst* <sub>[REG:ANY]</sub> = *src* <sub>[REG/CONST:SAME_AS_PREV]</sub>
Move between registers. While a mov can be emulated via a `zero add`, having a dedicated instruction make some optimizations easier to implement when combined with a canonicalization.

#### [35] cmpeq *dst* <sub>[REG:ANY]</sub> = *src1* <sub>[REG/CONST:SAME_AS_PREV]</sub> *src2* <sub>[REG/CONST:SAME_AS_PREV]</sub> *cmp1* <sub>[REG/CONST:SAME_AS_PREV]</sub> *cmp2* <sub>[REG/CONST:SAME_AS_PREV]</sub>
Conditional move (compare equal). dst := (cmp1 == cmp2) ? src1 : src2 Some day cmp1/cmp2 may be of a different type.

#### [36] cmplt *dst* <sub>[REG:ADDR_NUM]</sub> = *src1* <sub>[REG/CONST:SAME_AS_PREV]</sub> *src2* <sub>[REG/CONST:SAME_AS_PREV]</sub> *cmp1* <sub>[REG/CONST:SAME_AS_PREV]</sub> *cmp2* <sub>[REG/CONST:SAME_AS_PREV]</sub>
Conditional move (compare greater than). dst := (cmp1 < cmp2) ? src1 : src2 Some day cmp1/cmp2 may be of a different type.

## Address Arithmetic

#### [38] lea *dst* <sub>[REG:ADDR]</sub> = *base* <sub>[REG/CONST:SAME_AS_PREV]</sub> *offset* <sub>[REG/CONST:OFFSET]</sub>
Load effective Address. dst  := base + offset  
             
             (note: dst and base are addresses but offset is not)

#### [39] lea.mem *dst* <sub>[REG:ADDR]</sub> = *base* <sub>[MEM]</sub> *offset* <sub>[REG/CONST:OFFSET]</sub>
Load effective memory address with offset, dst := base + offset

#### [3a] lea.stk *dst* <sub>[REG:ADDR]</sub> = *base* <sub>[STK]</sub> *offset* <sub>[REG/CONST:OFFSET]</sub>
Load effective stack address with offset. dst := base + offset

#### [3b] lea.fun *dst* <sub>[REG:CODE]</sub> = *base* <sub>[FUN]</sub>
Load effective function address: dst := base (note: no offset).

## Load

#### [40] ld *dst* <sub>[REG:ANY]</sub> = *base* <sub>[REG/CONST:ADDR]</sub> *offset* <sub>[REG/CONST:OFFSET]</sub>
Load from register base with offset.  dst := RAM[base + offset]

#### [41] ld.mem *dst* <sub>[REG:ANY]</sub> = *base* <sub>[MEM]</sub> *offset* <sub>[REG/CONST:OFFSET]</sub>
Load from memory base with offset. dst := RAM[base + offset] 

#### [42] ld.stk *dst* <sub>[REG:ANY]</sub> = *base* <sub>[STK]</sub> *offset* <sub>[REG/CONST:OFFSET]</sub>
Load from stack base with offset. dst := RAM[base + offset]

## Store

#### [48] st *base* <sub>[REG:ADDR]</sub> *offset* <sub>[REG/CONST:OFFSET]</sub> = *src* <sub>[REG/CONST:ANY]</sub>
Store to register base with offset. RAM[base + offset] := src

#### [49] st.mem *base* <sub>[MEM]</sub> *offset* <sub>[REG/CONST:OFFSET]</sub> = *src* <sub>[REG/CONST:ANY]</sub>
Store to memory base with offset. RAM[base + offset] := src

#### [4a] st.stk *base* <sub>[STK]</sub> *offset* <sub>[REG/CONST:OFFSET]</sub> = *src* <sub>[REG/CONST:ANY]</sub>
Store to stack base with offset. RAM[base + offset] := src

## Misc

#### [f1] nop 
nop - internal use.

#### [f2] nop1 *src_and_dst* <sub>[REG:ANY]</sub> =
nop with one reg - internal use. can be used to `reserve` a reg for code generation

## Directives

#### [01] .mem *name* <sub>[NAME]</sub> *alignment* <sub>[CONST:UINT]</sub> *mem_kind* <sub>[MEM_KIND]</sub>
Add new memory region to unit

#### [02] .data *repeat* <sub>[CONST:UINT]</sub> *data* <sub>[BYTES]</sub>
Add content to current memory region: multiple bytes

#### [03] .addr.fun *width* <sub>[CONST:UINT]</sub> *fun* <sub>[FUN]</sub>
Add content to current memory region: code address

#### [04] .addr.mem *width* <sub>[CONST:UINT]</sub> *mem* <sub>[MEM]</sub> *offset* <sub>[CONST:OFFSET]</sub>
Add content to current memory region: memory address with offset

#### [05] .fun *name* <sub>[NAME]</sub> *fun_kind* <sub>[FUN_KIND]</sub> *out_params* <sub>[TYPE_LIST]</sub> *in_params* <sub>[TYPE_LIST]</sub>
Add new function to unit

#### [06] .bbl *name* <sub>[NAME]</sub>
Add new basic block to current function

#### [07] .reg *reg_kind* <sub>[DATA_KIND]</sub> *names* <sub>[NAME_LIST]</sub>
Add new registers to current function

#### [08] .stk *name* <sub>[NAME]</sub> *alignment* <sub>[CONST:UINT]</sub> *size* <sub>[CONST:UINT]</sub>
Add stack region to current function

#### [09] .jtb *name* <sub>[NAME]</sub> *size* <sub>[CONST:OFFSET]</sub> *default_bbl* <sub>[BBL]</sub> *map* <sub>[BBL_TAB]</sub>
bbl jump table: <name> <size> <default-bbl> <sparse-table>

<!--- @AUTOGEN-END@ --->


