// NOTE: this file is PARTIALLY autogenerated via: ./opcode_tab.py gen_c
#include "CpuX64/opcode_gen.h"
#include <iostream>
#include "Util/assert.h"

namespace cwerg::x64 {

// +-prefix converts an enum the underlying type
template <typename T>
constexpr auto operator+(T e) noexcept
    -> std::enable_if_t<std::is_enum<T>::value, std::underlying_type_t<T>> {
  return static_cast<std::underlying_type_t<T>>(e);
}


#include "CpuX64/opcode_gen_encodings.h"
#include "CpuX64/opcode_gen_names.h"
#include "CpuX64/opcode_gen_collisions.h"

/* @AUTOGEN-START@ */

const char* const OK_ToStringMap[] = {
    "", // 0
    "RIP_BASE", // 1
    "MODRM_RM_BASE", // 2
    "OFFABS8", // 3
    "OFFABS32", // 4
    "SIB_SCALE", // 5
    "SIB_INDEX", // 6
    "SIB_BASE", // 7
    "SIB_INDEX_AS_BASE", // 8
    "", // 9
    "IMM8", // 10
    "IMM16", // 11
    "IMM32", // 12
    "OFFPCREL8", // 13
    "OFFPCREL32", // 14
    "", // 15
    "", // 16
    "IMM8_16", // 17
    "IMM8_32", // 18
    "IMM8_64", // 19
    "IMM32_64", // 20
    "IMM64", // 21
    "", // 22
    "", // 23
    "BYTE_WITH_REG8", // 24
    "BYTE_WITH_REG16", // 25
    "BYTE_WITH_REG32", // 26
    "BYTE_WITH_REG64", // 27
    "MODRM_RM_REG8", // 28
    "MODRM_RM_REG16", // 29
    "MODRM_RM_REG32", // 30
    "MODRM_RM_REG64", // 31
    "MODRM_RM_XREG32", // 32
    "MODRM_RM_XREG64", // 33
    "MODRM_RM_XREG128", // 34
    "MODRM_REG8", // 35
    "MODRM_REG16", // 36
    "MODRM_REG32", // 37
    "MODRM_REG64", // 38
    "MODRM_XREG32", // 39
    "MODRM_XREG64", // 40
    "MODRM_XREG128", // 41
    "", // 42
    "", // 43
    "", // 44
    "", // 45
    "", // 46
    "", // 47
    "", // 48
    "", // 49
    "IMPLICIT_AL", // 50
    "IMPLICIT_AX", // 51
    "IMPLICIT_EAX", // 52
    "IMPLICIT_RAX", // 53
    "IMPLICIT_DX", // 54
    "IMPLICIT_EDX", // 55
    "IMPLICIT_RDX", // 56
    "IMPLICIT_CL", // 57
    "", // 58
    "", // 59
    "", // 60
    "", // 61
    "", // 62
    "", // 63
    "", // 64
    "", // 65
    "", // 66
    "", // 67
    "IMPLICIT_1", // 68
};
const char* EnumToString(OK x) { return OK_ToStringMap[unsigned(x)]; }

/* @AUTOGEN-END@ */
size_t GetRexPos(const Opcode& opcode, std::string_view data) {
  for (size_t i = 0; i < data.size(); ++i) {
    uint8_t d = data[i];
    if (d == 0x66 || d == 0xf2 || d == 0xf3) continue;
    if ((d & 0xf0) == 0x40) return i;
    break;
  }
  return opcode.num_bytes;
}

uint64_t GetRegBits(std::string_view data,
                    size_t rex_pos,
                    uint32_t offset,
                    uint32_t data_bit_pos,
                    uint32_t rex_bit_pos) {
  if (offset >= rex_pos) offset += 1;

  uint64_t r = (data[offset] >> data_bit_pos) & 0x7;
  if (rex_pos < offset) {
    r |= ((data[rex_pos] >> rex_bit_pos) & 1) << 3;
  }
  return r;
}

uint64_t GetSInt(std::string_view data,
                 size_t rex_pos,
                 uint32_t pos,
                 uint32_t src_width,
                 uint32_t dst_width) {
  if (pos >= rex_pos) pos += 1;
  uint64_t r = int8_t(data[pos++]);
  while (pos < src_width) {
    r = (r << 8) | data[pos++];
  }

  if (dst_width == 0 or dst_width == 64) return r;
  return r & ((1 << dst_width) - 1);
}

uint64_t GetOperand(OK ok,
                    const Opcode& opcode,
                    std::string_view data,
                    size_t rex_pos) {
  switch (ok) {
    case OK::IMPLICIT_AL:
    case OK::IMPLICIT_AX:
    case OK::IMPLICIT_EAX:
    case OK::IMPLICIT_RAX:
    case OK::IMPLICIT_DX:
    case OK::IMPLICIT_EDX:
    case OK::IMPLICIT_RDX:
    case OK::IMPLICIT_CL:
    case OK::IMPLICIT_1:
      return 0;
    case OK::MODRM_RM_REG8:
    case OK::MODRM_RM_REG16:
    case OK::MODRM_RM_REG32:
    case OK::MODRM_RM_REG64: {
      uint64_t result = GetRegBits(data, rex_pos, opcode.modrm_pos, 0, 0);
      if (ok == OK::MODRM_RM_REG8 && 4 <= result && result <= 7) {
        ASSERT(rex_pos <= opcode.modrm_pos, "");
      }
      return result;
    }
    case OK::MODRM_RM_XREG32:
    case OK::MODRM_RM_XREG64:
    case OK::MODRM_RM_XREG128:
    case OK::MODRM_RM_BASE:
      return GetRegBits(data, rex_pos, opcode.modrm_pos, 0, 0);
    case OK::MODRM_REG8:
    case OK::MODRM_REG16:
    case OK::MODRM_REG32:
    case OK::MODRM_REG64: {
      uint64_t result = GetRegBits(data, rex_pos, opcode.modrm_pos, 3, 2);
      if (ok == OK::MODRM_REG8 && 4 <= result && result <= 7) {
        ASSERT(rex_pos <= opcode.modrm_pos, "");
      }
      return result;
    }
    case OK::MODRM_XREG32:
    case OK::MODRM_XREG64:
    case OK::MODRM_XREG128:
      return GetRegBits(data, rex_pos, opcode.modrm_pos, 3, 2);
    case OK::RIP_BASE:
      return 0;
    case OK::SIB_BASE:
      return GetRegBits(data, rex_pos, opcode.sib_pos, 0, 0);
    case OK::SIB_INDEX:
      return GetRegBits(data, rex_pos, opcode.sib_pos, 3, 1);
    case OK::SIB_INDEX_AS_BASE: {
      uint64_t result = GetRegBits(data, rex_pos, opcode.sib_pos, 3, 1);
      ASSERT(result != 4, "");
      return result;
    }
    case OK::SIB_SCALE:
      return data[opcode.sib_pos + uint32_t(rex_pos <= opcode.sib_pos)] >> 6;
    case OK::BYTE_WITH_REG8: {
      uint64_t result =
          GetRegBits(data, rex_pos, opcode.byte_with_reg_pos, 0, 0);
      ASSERT(4 <= result && result <= 7, "");
      return result;
    }
    case OK::BYTE_WITH_REG16:
    case OK::BYTE_WITH_REG32:
    case OK::BYTE_WITH_REG64:
      return GetRegBits(data, rex_pos, opcode.byte_with_reg_pos, 0, 0);
    case OK::IMM8:
      return GetSInt(data, rex_pos, opcode.imm_pos, 8, 8);
    case OK::IMM16:
      return GetSInt(data, rex_pos, opcode.imm_pos, 16, 16);
    case OK::IMM32:
      return GetSInt(data, rex_pos, opcode.imm_pos, 32, 32);
    case OK::IMM8_16:
      return GetSInt(data, rex_pos, opcode.imm_pos, 8, 16);
    case OK::IMM8_32:
      return GetSInt(data, rex_pos, opcode.imm_pos, 8, 32);
    case OK::IMM8_64:
      return GetSInt(data, rex_pos, opcode.imm_pos, 8, 64);
    case OK::IMM32_64:
      return GetSInt(data, rex_pos, opcode.imm_pos, 32, 64);
    case OK::IMM64:
      return GetSInt(data, rex_pos, opcode.imm_pos, 64, 64);
    case OK::OFFPCREL8:
      return GetRegBits(data, rex_pos, opcode.offset_pos, 8, 0);
    case OK::OFFPCREL32:
      return GetRegBits(data, rex_pos, opcode.offset_pos, 32, 0);
    case OK::OFFABS8:
      return GetRegBits(data, rex_pos, opcode.offset_pos, 8, 0);
    case OK::OFFABS32:
      return GetRegBits(data, rex_pos, opcode.offset_pos, 32, 0);
  }
  ASSERT(false, "");
  return 0;
}

uint32_t _FP(bool b66, bool bf2, bool bf3, bool b0f, bool b48, uint8_t d) {
  return (b66 << 12) | (bf2 << 11) | (bf3 << 10) | (b0f << 9) | (b48 << 8) | d;
}

uint32_t FingerPrintRawInstructions(std::string_view data) {
  bool b48 = false;
  bool bf2 = false;
  bool bf3 = false;
  bool b66 = false;
  for (size_t i = 0; i < data.size(); ++i) {
    uint8_t d = data[i];
    if ((d & 0xf0) == 040)
      b48 = (d >> 3) & 1;
    else if (d == 0x66)
      b66 = true;
    else if (d == 0xf2)
      bf2 = true;
    else if (d == 0xf3)
      bf3 = true;
    else if (d == 0x0f) {
      ASSERT(i + 1 < data.size(), "");
      return _FP(b66, bf2, bf3, 1, b48, data[i + 1]);
    } else
      return _FP(b66, bf2, bf3, 1, b48, d);
  }
  ASSERT(false, "unreachable");
  return 0;
}

bool OpcodeMatchesData(const Opcode& opcode, std::string_view data) {
  const size_t rex_pos = GetRexPos(opcode, data);

  if (data.size() < opcode.num_bytes + unsigned(rex_pos != opcode.num_bytes))
    return false;

  size_t n = 0;
  for (size_t i = 0; i < opcode.num_bytes; ++i) {
    const uint8_t d = opcode.data[i];
    const uint8_t m = opcode.mask[i];
    if (n == rex_pos) ++n;
    const uint8_t x = data[n];
    if ((d & m) != (x & m)) return false;
  }

  return true;
}

const Opcode* FindOpcode(std::string_view data) {
  uint32_t index =
      FingerprintToCollisionIndex[FingerPrintRawInstructions(data)];
  while (true) {
    const OPC opc = FingerprintCollisions[index++];
    if (opc == OPC::invalid) return nullptr;
    const Opcode& opcode = OpcodeTableEncodings[+opc];
    if (OpcodeMatchesData(opcode, data)) return &opcode;
  }
  return nullptr;
}

bool Disassemble(Ins* ins, std::string_view data) {
  const Opcode* opcode = FindOpcode(data);
  if (opcode == nullptr) return false;
  ins->opcode = opcode;
  const size_t rex_pos = GetRexPos(*opcode, data);
  int i = 0;
  for (OK ok : opcode->fields) {
    ins->operands[i++] = GetOperand(ok, *opcode, data, rex_pos);
  }
  ins->clear_reloc();
  return true;
}

}  // namespace cwerg::x64
