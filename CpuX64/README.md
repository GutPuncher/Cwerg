# X64(-64) Encoder/Decoder

X86 is a pretty messy ISA to target for a compiler backend.
Targeting may not be possible within our complexity budget of 5k LOC
but it is also the dominant ISA on the desktop so it would be really nice
to support it.

Know difficulties:
* ISA is closer to a 2-addr than a 3-addr instruction set
  LLVM has a special pass for this. The concept of "tied" registers is helpful
  here.
  Meaning a register is used in multiple slots, ARM32 also has a few of those.
  Memory operands aggravate the problem.
  On the other hand, doing away with register allocation and just keeping all
  locals on the stack may be good enough. 
* Variable length instructions, especially for branches, require a relaxation
  pass to pick the shortest encoding possible
* Some registers are [implicit](https://reverseengineering.stackexchange.com/questions/12379/xclist-of-x86-x64-instructions-that-implicitly-access-registers)
  This can be handled by forcing a machine register for 
  an Ins and moving data into this register from a virtual register.
* Complex address modes



## References

* asmdb https://github.com/asmjit/asmdb/blob/master/armdata.js
* asmgrid https://asmjit.com/asmgrid/
* asmjit https://github.com/asmjit/asmjit/blob/master/src/asmjit/x86/x86instdb.cpp
* sandpile.org https://sandpile.org/
* zydis https://github.com/zyantific/zydis
* xed https://github.com/intelxed/xed
* PeachPy https://github.com/Maratyszcza/PeachPy
* https://godbolt.org/ check target code generated by various compilers 
* https://reverseengineering.stackexchange.com/questions/12379/xclist-of-x86-x64-instructions-that-implicitly-access-registers
