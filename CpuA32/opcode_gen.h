#pragma once
// (c) Robert Muth - see LICENSE for more info
// NOTE: this file is PARTIALLY autogenerated via: ./opcode_tab.py gen_h

#include "Elf/enum_gen.h"  // for reloc types

#include <cstdint>
#include <string_view>

namespace cwerg::a32 {
using namespace cwerg;

constexpr const unsigned MAX_OPERANDS = 7;
constexpr const unsigned MAX_BIT_RANGES = 4;

/* @AUTOGEN-START@ */

enum class OK : uint8_t {
    Invalid = 0,
    REG_0_3 = 1,
    REG_8_11 = 2,
    REG_12_15 = 3,
    REG_16_19 = 4,
    REG_LINK = 5,
    REG_PAIR_12_15 = 6,
    DREG_0_3_5 = 7,
    DREG_12_15_22 = 8,
    DREG_16_19_7 = 9,
    SREG_0_3_5 = 10,
    SREG_12_15_22 = 11,
    SREG_16_19_7 = 12,
    SHIFT_MODE_5_6 = 13,
    SHIFT_MODE_5_6_ADDR = 14,
    SHIFT_MODE_ROT = 15,
    REGLIST_0_15 = 16,
    REG_RANGE_0_7 = 17,
    REG_RANGE_1_7 = 18,
    PRED_28_31 = 19,
    ADDR_BASE_ONLY = 20,
    ADDR_BASE_WITH_OFFSET = 21,
    ADDR_BASE_WITH_OFFSET2 = 22,
    ADDR_MULTI = 23,
    IMM_0_7_times4 = 24,
    IMM_0_11 = 25,
    IMM_0_3_8_11 = 26,
    IMM_7_11 = 27,
    IMM_10_11 = 28,
    IMM_0_23 = 29,
    IMM_0_7_8_11 = 30,
    IMM_ZERO = 31,
    IMM_0_11_16_19 = 32,
    SIMM_0_23 = 33,
};

enum class SR_UPDATE : uint8_t {
    NONE = 0,
    NZ = 1,
    NCZ_PSR = 2,
    NCZ = 4,
    NCZV = 5,
};

enum class BitRangeKind : uint8_t {
    Verbatim = 0,
    Hi = 1,
    Lo = 2,
    Rotated = 3,
    Signed = 4,
    Times8 = 5,
    Times4 = 6,
    Times2 = 7,
    Times2Plus4 = 8,
    Force0 = 9,
    Force1 = 10,
    Force3 = 11,
    Force6 = 12,
    Force14 = 13,
    U = 14,
    W = 15,
    P = 16,
};

enum class MEM_WIDTH : uint8_t {
    NA = 0,
    W1 = 1,
    W2 = 2,
    W4 = 3,
    W8 = 4,
    W12 = 5,
    Variable = 6,
};

enum OPC_FLAG {
    RESULT_64BIT = 1,
    SRC_DST_0_1 = 2,
    DST_0_1 = 4,
    DIV = 8,
    MUL = 16,
    MULACC = 32,
    LOAD = 64,
    STORE = 128,
    ATOMIC = 0x100,
    ALU = 0x200,
    ALU1 = 0x400,
    SIGNEXTEND = 0x800,
    JUMP = 0x1000,
    LINK = 0x2000,
    THUMB = 0x4000,
    MOVETOSR = 0x8000,
    MOVEFROMSR = 0x10000,
    TEST = 0x20000,
    PREFETCH = 0x40000,
    MULTIPLE = 0x80000,
    VFP = 0x100000,
    SYSCALL = 0x200000,
    BYTEREORDER = 0x400000,
    MISC = 0x800000,
};

enum class PRED : uint8_t {
    eq = 0,
    ne = 1,
    cs = 2,
    cc = 3,
    mi = 4,
    pl = 5,
    vs = 6,
    vc = 7,
    hi = 8,
    ls = 9,
    ge = 10,
    lt = 11,
    gt = 12,
    le = 13,
    al = 14,
    invalid_pred = 15,
};

enum class REG : uint8_t {
    r0 = 0,
    r1 = 1,
    r2 = 2,
    r3 = 3,
    r4 = 4,
    r5 = 5,
    r6 = 6,
    r7 = 7,
    r8 = 8,
    r9 = 9,
    sl = 10,
    fp = 11,
    ip = 12,
    sp = 13,
    lr = 14,
    pc = 15,
};

enum class SREG : uint8_t {
    s0 = 0,
    s1 = 1,
    s2 = 2,
    s3 = 3,
    s4 = 4,
    s5 = 5,
    s6 = 6,
    s7 = 7,
    s8 = 8,
    s9 = 9,
    s10 = 10,
    s11 = 11,
    s12 = 12,
    s13 = 13,
    s14 = 14,
    s15 = 15,
    s16 = 16,
    s17 = 17,
    s18 = 18,
    s19 = 19,
    s20 = 20,
    s21 = 21,
    s22 = 22,
    s23 = 23,
    s24 = 24,
    s25 = 25,
    s26 = 26,
    s27 = 27,
    s28 = 28,
    s29 = 29,
    s30 = 30,
    s31 = 31,
};

enum class DREG : uint8_t {
    d0 = 0,
    d1 = 1,
    d2 = 2,
    d3 = 3,
    d4 = 4,
    d5 = 5,
    d6 = 6,
    d7 = 7,
    d8 = 8,
    d9 = 9,
    d10 = 10,
    d11 = 11,
    d12 = 12,
    d13 = 13,
    d14 = 14,
    d15 = 15,
};

enum class ADDR_MODE : uint8_t {
    puw = 0,
    puW = 1,
    pUw = 2,
    pUW = 3,
    Puw = 4,
    PuW = 5,
    PUw = 6,
    PUW = 7,
};

enum class SHIFT : uint8_t {
    lsl = 0,
    lsr = 1,
    asr = 2,
    ror_rrx = 3,
};

enum class OPC : uint16_t {
    invalid,
    mul,
    mla,
    umull,
    umlal,
    smull,
    smlal,
    muls,
    mlas,
    umulls,
    umlals,
    smulls,
    smlals,
    mls,
    smlabb,
    smulbb,
    smlatb,
    smultb,
    smlabt,
    smulbt,
    smlatt,
    smultt,
    strex,
    ldrex,
    ldrh_imm,
    ldrsb_imm,
    ldrsh_imm,
    strh_imm,
    ldrd_imm,
    strd_imm,
    ldrh_reg,
    ldrsb_reg,
    ldrsh_reg,
    strh_reg,
    ldrd_reg,
    strd_reg,
    and_regreg,
    and_regimm,
    ands_regreg,
    ands_regimm,
    eor_regreg,
    eor_regimm,
    eors_regreg,
    eors_regimm,
    sub_regreg,
    sub_regimm,
    subs_regreg,
    subs_regimm,
    rsb_regreg,
    rsb_regimm,
    rsbs_regreg,
    rsbs_regimm,
    add_regreg,
    add_regimm,
    adds_regreg,
    adds_regimm,
    adc_regreg,
    adc_regimm,
    adcs_regreg,
    adcs_regimm,
    sbc_regreg,
    sbc_regimm,
    sbcs_regreg,
    sbcs_regimm,
    rsc_regreg,
    rsc_regimm,
    rscs_regreg,
    rscs_regimm,
    orr_regreg,
    orr_regimm,
    orrs_regreg,
    orrs_regimm,
    bic_regreg,
    bic_regimm,
    bics_regreg,
    bics_regimm,
    swp,
    swpb,
    bx,
    blx_reg,
    clz,
    tst_regreg,
    tst_regimm,
    teq_regreg,
    teq_regimm,
    cmp_regreg,
    cmp_regimm,
    cmn_regreg,
    cmn_regimm,
    mov_regreg,
    mov_regimm,
    movs_regreg,
    movs_regimm,
    mvn_regreg,
    mvn_regimm,
    mvns_regreg,
    mvns_regimm,
    and_imm,
    ands_imm,
    eor_imm,
    eors_imm,
    sub_imm,
    subs_imm,
    rsb_imm,
    rsbs_imm,
    add_imm,
    adds_imm,
    adc_imm,
    adcs_imm,
    sbc_imm,
    sbcs_imm,
    rsc_imm,
    rscs_imm,
    orr_imm,
    orrs_imm,
    bic_imm,
    bics_imm,
    tst_imm,
    teq_imm,
    cmp_imm,
    cmn_imm,
    mov_imm,
    movs_imm,
    mvn_imm,
    mvns_imm,
    movw,
    movt,
    ldp_imm,
    ldr_imm,
    str_imm,
    ldrb_imm,
    strb_imm,
    sdiv,
    udiv,
    uxtb,
    sxtb,
    uxtab,
    sxtab,
    uxtb16,
    sxtb16,
    uxtab16,
    sxtab16,
    uxth,
    sxth,
    uxtah,
    sxtah,
    rev,
    rev16,
    ldp_reg,
    ldr_reg,
    str_reg,
    ldrb_reg,
    strb_reg,
    ud2,
    stm,
    ldm,
    b,
    bl,
    vldr_f32,
    vldr_f64,
    vstr_f32,
    vstr_f64,
    vmov_atof,
    vmov_ftoa,
    vldm_s,
    vldm_f,
    vstm_s,
    vstm_f,
    svc,
    vmov_atos,
    vmov_stoa,
    vcvt_f32_f64,
    vcvt_f64_f32,
    vcvt_s32_f64,
    vcvt_s32_f32,
    vcvt_u32_f64,
    vcvt_u32_f32,
    vcvt_f64_s32,
    vcvt_f32_s32,
    vcvt_f64_u32,
    vcvt_f32_u32,
    vcmp_f32,
    vcmp_f64,
    vcmp_f32_zero,
    vcmp_f64_zero,
    vcmpe_f32,
    vcmpe_f64,
    vcmpe_f32_zero,
    vcmpe_f64_zero,
    vabs_f32,
    vabs_f64,
    vmov_f32,
    vmov_f64,
    vsqrt_f32,
    vsqrt_f64,
    vneg_f32,
    vneg_f64,
    vdiv_f32,
    vdiv_f64,
    vmul_f32,
    vmul_f64,
    vadd_f32,
    vadd_f64,
    vsub_f32,
    vsub_f64,
    vnmul_f32,
    vnmul_f64,
    vnmls_f32,
    vnmls_f64,
    vnmla_f32,
    vnmla_f64,
    vmls_f32,
    vmls_f64,
    vmla_f32,
    vmla_f64,
    vmrs_APSR_nzcv_fpscr,
};
/* @AUTOGEN-END@ */

// Describes a class of instructions structurally (read-only data).
struct Opcode {
  const char* name;
  const char* enum_name;
  uint32_t bit_mask;
  uint32_t bit_value;
  uint8_t num_fields;
  OK fields[MAX_OPERANDS];
  uint32_t classes;
  MEM_WIDTH mem_width;
  SR_UPDATE sr_update;
};

// Indexed by ArmINS
extern const Opcode OpcodeTable[];

// Find the Opcode or null for a 32 bit instruction word
extern const Opcode* FindArmOpcode(uint32_t bit_value);

extern const Opcode* FindArmOpcodeForMnemonic(std::string_view s);

// Returns non-zero if successful
extern int32_t DecodeOperand(uint32_t data, OK field_kind);

// Decoded representation of the instruction word
struct Ins {
  const Opcode* opcode;
  // number of used entries is ArmOpcode.num_fields
  // This is signed because some operands can be negative, e.g.
  // branch offset, but this is not ideal since immediates
  // for add/sub/and etc can produce unsigned immediates with
  // high order bit set.
  int32_t operands[MAX_OPERANDS];
  // Relocation info
  std::string_view reloc_symbol;
  elf::RELOC_TYPE_ARM reloc_kind = elf::RELOC_TYPE_ARM::NONE;
  uint8_t reloc_pos;  // index into  operands

  bool has_reloc() const { return reloc_kind != elf::RELOC_TYPE_ARM::NONE; }

  void clear_reloc() {
    if (has_reloc()) {
      reloc_kind = elf::RELOC_TYPE_ARM::NONE;
      operands[reloc_pos] = 0;
    }
  }
};

// Decode the instruction word `data`
// Returns true if successful
extern bool DecodeIns(Ins* ins, uint32_t data);

// Encode the instruction
// Returns the instruction word. Asserts if unsuccessful
extern uint32_t EncodeIns(const Ins& ins);

// Tries to encode a 32 bit immediate value as a standard
// ARM 12bit shifted immediate.
// If this is successful a 12bit unsigned value is returned.
// Otherwise, -1 is returned.
extern int32_t EncodeRotatedImm(int32_t immediate);

template <typename Flag>
const char* EnumToString(Flag f);

}  // namespace cwerg::a32

