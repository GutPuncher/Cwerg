#pragma once
// (c) Robert Muth - see LICENSE for more info
// NOTE: this file is PARTIALLY autogenerated via: ./opcode_tab.py gen_h

#include "Elf/enum_gen.h"  // for reloc types

#include <cstdint>
#include <string_view>

namespace cwerg::a32 {
using namespace cwerg;

constexpr const unsigned MAX_OPERANDS = 7;
constexpr const unsigned MAX_BIT_RANGES = 4;

/* @AUTOGEN-START@ */

enum class OK : uint8_t {
    Invalid = 0,
    REG_0_3 = 1,
    REG_8_11 = 2,
    REG_12_15 = 3,
    REG_16_19 = 4,
    REG_LINK = 5,
    REG_PAIR_12_15 = 6,
    DREG_0_3_5 = 7,
    DREG_12_15_22 = 8,
    DREG_16_19_7 = 9,
    SREG_0_3_5 = 10,
    SREG_12_15_22 = 11,
    SREG_16_19_7 = 12,
    SHIFT_MODE_5_6 = 13,
    SHIFT_MODE_5_6_ADDR = 14,
    SHIFT_MODE_ROT = 15,
    REGLIST_0_15 = 16,
    REG_RANGE_0_7 = 17,
    REG_RANGE_1_7 = 18,
    REG_BASE_16_19 = 19,
    PRED_28_31 = 20,
    IMM_0_7_TIMES_4 = 21,
    IMM_0_11 = 22,
    IMM_0_3_8_11 = 23,
    IMM_7_11 = 24,
    IMM_10_11_TIMES_8 = 25,
    IMM_0_23 = 26,
    IMM_0_7_8_11 = 27,
    IMM_ZERO = 28,
    IMM_0_11_16_19 = 29,
    SIMM_0_23 = 30,
};

enum class SR_UPDATE : uint8_t {
    NONE = 0,
    NZ = 1,
    NCZ_PSR = 2,
    NCZ = 4,
    NCZV = 5,
};

enum class MEM_WIDTH : uint8_t {
    NA = 0,
    W1 = 1,
    W2 = 2,
    W4 = 3,
    W8 = 4,
    W12 = 5,
    Variable = 6,
};

enum OPC_FLAG {
    RESULT_64BIT = 1,
    SRC_DST_0_1 = 2,
    DST_0_1 = 4,
    DIV = 8,
    MUL = 16,
    MULACC = 32,
    LOAD = 64,
    STORE = 128,
    ATOMIC = 0x100,
    ALU = 0x200,
    ALU1 = 0x400,
    SIGNEXTEND = 0x800,
    JUMP = 0x1000,
    LINK = 0x2000,
    THUMB = 0x4000,
    MOVETOSR = 0x8000,
    MOVEFROMSR = 0x10000,
    TEST = 0x20000,
    PREFETCH = 0x40000,
    MULTIPLE = 0x80000,
    VFP = 0x100000,
    SYSCALL = 0x200000,
    BYTEREORDER = 0x400000,
    MISC = 0x800000,
    ADDR_PRE = 0x1000000,
    ADDR_POST = 0x2000000,
    ADDR_INC = 0x4000000,
    ADDR_DEC = 0x8000000,
    ADDR_UPDATE = 0x10000000,
};

enum class PRED : uint8_t {
    eq = 0,
    ne = 1,
    cs = 2,
    cc = 3,
    mi = 4,
    pl = 5,
    vs = 6,
    vc = 7,
    hi = 8,
    ls = 9,
    ge = 10,
    lt = 11,
    gt = 12,
    le = 13,
    al = 14,
    invalid_pred = 15,
};

enum class REG : uint8_t {
    r0 = 0,
    r1 = 1,
    r2 = 2,
    r3 = 3,
    r4 = 4,
    r5 = 5,
    r6 = 6,
    r7 = 7,
    r8 = 8,
    r9 = 9,
    sl = 10,
    fp = 11,
    ip = 12,
    sp = 13,
    lr = 14,
    pc = 15,
};

enum class SREG : uint8_t {
    s0 = 0,
    s1 = 1,
    s2 = 2,
    s3 = 3,
    s4 = 4,
    s5 = 5,
    s6 = 6,
    s7 = 7,
    s8 = 8,
    s9 = 9,
    s10 = 10,
    s11 = 11,
    s12 = 12,
    s13 = 13,
    s14 = 14,
    s15 = 15,
    s16 = 16,
    s17 = 17,
    s18 = 18,
    s19 = 19,
    s20 = 20,
    s21 = 21,
    s22 = 22,
    s23 = 23,
    s24 = 24,
    s25 = 25,
    s26 = 26,
    s27 = 27,
    s28 = 28,
    s29 = 29,
    s30 = 30,
    s31 = 31,
};

enum class DREG : uint8_t {
    d0 = 0,
    d1 = 1,
    d2 = 2,
    d3 = 3,
    d4 = 4,
    d5 = 5,
    d6 = 6,
    d7 = 7,
    d8 = 8,
    d9 = 9,
    d10 = 10,
    d11 = 11,
    d12 = 12,
    d13 = 13,
    d14 = 14,
    d15 = 15,
};

enum class SHIFT : uint8_t {
    lsl = 0,
    lsr = 1,
    asr = 2,
    ror_rrx = 3,
};

enum class OPC : uint16_t {
    invalid,
    mul,
    mla,
    umull,
    umlal,
    smull,
    smlal,
    muls,
    mlas,
    umulls,
    umlals,
    smulls,
    smlals,
    mls,
    smlabb,
    smulbb,
    smlatb,
    smultb,
    smlabt,
    smulbt,
    smlatt,
    smultt,
    strex,
    ldrex,
    ldrh_imm_sub_post,
    ldrsb_imm_sub_post,
    ldrsh_imm_sub_post,
    strh_imm_sub_post,
    ldrd_imm_sub_post,
    strd_imm_sub_post,
    ldrh_reg_sub_post,
    ldrsb_reg_sub_post,
    ldrsh_reg_sub_post,
    strh_reg_sub_post,
    ldrd_reg_sub_post,
    strd_reg_sub_post,
    ldrh_imm_add_post,
    ldrsb_imm_add_post,
    ldrsh_imm_add_post,
    strh_imm_add_post,
    ldrd_imm_add_post,
    strd_imm_add_post,
    ldrh_reg_add_post,
    ldrsb_reg_add_post,
    ldrsh_reg_add_post,
    strh_reg_add_post,
    ldrd_reg_add_post,
    strd_reg_add_post,
    ldrh_imm_sub,
    ldrsb_imm_sub,
    ldrsh_imm_sub,
    strh_imm_sub,
    ldrd_imm_sub,
    strd_imm_sub,
    ldrh_reg_sub,
    ldrsb_reg_sub,
    ldrsh_reg_sub,
    strh_reg_sub,
    ldrd_reg_sub,
    strd_reg_sub,
    ldrh_imm_add,
    ldrsb_imm_add,
    ldrsh_imm_add,
    strh_imm_add,
    ldrd_imm_add,
    strd_imm_add,
    ldrh_reg_add,
    ldrsb_reg_add,
    ldrsh_reg_add,
    strh_reg_add,
    ldrd_reg_add,
    strd_reg_add,
    ldrh_imm_sub_pre,
    ldrsb_imm_sub_pre,
    ldrsh_imm_sub_pre,
    strh_imm_sub_pre,
    ldrd_imm_sub_pre,
    strd_imm_sub_pre,
    ldrh_reg_sub_pre,
    ldrsb_reg_sub_pre,
    ldrsh_reg_sub_pre,
    strh_reg_sub_pre,
    ldrd_reg_sub_pre,
    strd_reg_sub_pre,
    ldrh_imm_add_pre,
    ldrsb_imm_add_pre,
    ldrsh_imm_add_pre,
    strh_imm_add_pre,
    ldrd_imm_add_pre,
    strd_imm_add_pre,
    ldrh_reg_add_pre,
    ldrsb_reg_add_pre,
    ldrsh_reg_add_pre,
    strh_reg_add_pre,
    ldrd_reg_add_pre,
    strd_reg_add_pre,
    and_regreg,
    and_regimm,
    ands_regreg,
    ands_regimm,
    eor_regreg,
    eor_regimm,
    eors_regreg,
    eors_regimm,
    sub_regreg,
    sub_regimm,
    subs_regreg,
    subs_regimm,
    rsb_regreg,
    rsb_regimm,
    rsbs_regreg,
    rsbs_regimm,
    add_regreg,
    add_regimm,
    adds_regreg,
    adds_regimm,
    adc_regreg,
    adc_regimm,
    adcs_regreg,
    adcs_regimm,
    sbc_regreg,
    sbc_regimm,
    sbcs_regreg,
    sbcs_regimm,
    rsc_regreg,
    rsc_regimm,
    rscs_regreg,
    rscs_regimm,
    orr_regreg,
    orr_regimm,
    orrs_regreg,
    orrs_regimm,
    bic_regreg,
    bic_regimm,
    bics_regreg,
    bics_regimm,
    swp,
    swpb,
    bx,
    blx_reg,
    clz,
    tst_regreg,
    tst_regimm,
    teq_regreg,
    teq_regimm,
    cmp_regreg,
    cmp_regimm,
    cmn_regreg,
    cmn_regimm,
    mov_regreg,
    mov_regimm,
    movs_regreg,
    movs_regimm,
    mvn_regreg,
    mvn_regimm,
    mvns_regreg,
    mvns_regimm,
    and_imm,
    ands_imm,
    eor_imm,
    eors_imm,
    sub_imm,
    subs_imm,
    rsb_imm,
    rsbs_imm,
    add_imm,
    adds_imm,
    adc_imm,
    adcs_imm,
    sbc_imm,
    sbcs_imm,
    rsc_imm,
    rscs_imm,
    orr_imm,
    orrs_imm,
    bic_imm,
    bics_imm,
    tst_imm,
    teq_imm,
    cmp_imm,
    cmn_imm,
    mov_imm,
    movs_imm,
    mvn_imm,
    mvns_imm,
    movw,
    movt,
    ldp_imm_sub_post,
    ldr_imm_sub_post,
    str_imm_sub_post,
    ldrb_imm_sub_post,
    strb_imm_sub_post,
    ldp_imm_add_post,
    ldr_imm_add_post,
    str_imm_add_post,
    ldrb_imm_add_post,
    strb_imm_add_post,
    ldp_imm_sub,
    ldr_imm_sub,
    str_imm_sub,
    ldrb_imm_sub,
    strb_imm_sub,
    ldp_imm_add,
    ldr_imm_add,
    str_imm_add,
    ldrb_imm_add,
    strb_imm_add,
    ldp_imm_sub_pre,
    ldr_imm_sub_pre,
    str_imm_sub_pre,
    ldrb_imm_sub_pre,
    strb_imm_sub_pre,
    ldp_imm_add_pre,
    ldr_imm_add_pre,
    str_imm_add_pre,
    ldrb_imm_add_pre,
    strb_imm_add_pre,
    sdiv,
    udiv,
    uxtb,
    sxtb,
    uxtab,
    sxtab,
    uxtb16,
    sxtb16,
    uxtab16,
    sxtab16,
    uxth,
    sxth,
    uxtah,
    sxtah,
    rev,
    rev16,
    ldp_reg_sub_post,
    ldr_reg_sub_post,
    str_reg_sub_post,
    ldrb_reg_sub_post,
    strb_reg_sub_post,
    ldp_reg_add_post,
    ldr_reg_add_post,
    str_reg_add_post,
    ldrb_reg_add_post,
    strb_reg_add_post,
    ldp_reg_sub,
    ldr_reg_sub,
    str_reg_sub,
    ldrb_reg_sub,
    strb_reg_sub,
    ldp_reg_add,
    ldr_reg_add,
    str_reg_add,
    ldrb_reg_add,
    strb_reg_add,
    ldp_reg_sub_pre,
    ldr_reg_sub_pre,
    str_reg_sub_pre,
    ldrb_reg_sub_pre,
    strb_reg_sub_pre,
    ldp_reg_add_pre,
    ldr_reg_add_pre,
    str_reg_add_pre,
    ldrb_reg_add_pre,
    strb_reg_add_pre,
    ud2,
    stmda,
    ldmda,
    stmia,
    ldmia,
    stmdb,
    ldmdb,
    stmib,
    ldmib,
    stmda_update,
    ldmda_update,
    stmia_update,
    ldmia_update,
    stmdb_update,
    ldmdb_update,
    stmib_update,
    ldmib_update,
    b,
    bl,
    vldr_f32_sub,
    vldr_f64_sub,
    vstr_f32_sub,
    vstr_f64_sub,
    vldr_f32_add,
    vldr_f64_add,
    vstr_f32_add,
    vstr_f64_add,
    vmov_atof,
    vmov_ftoa,
    vldmda_s,
    vldmda_f,
    vstmda_s,
    vstmda_f,
    vldmia_s,
    vldmia_f,
    vstmia_s,
    vstmia_f,
    vldmdb_s,
    vldmdb_f,
    vstmdb_s,
    vstmdb_f,
    vldmib_s,
    vldmib_f,
    vstmib_s,
    vstmib_f,
    vldmda_s_update,
    vldmda_f_update,
    vstmda_s_update,
    vstmda_f_update,
    vldmia_s_update,
    vldmia_f_update,
    vstmia_s_update,
    vstmia_f_update,
    vldmdb_s_update,
    vldmdb_f_update,
    vstmdb_s_update,
    vstmdb_f_update,
    vldmib_s_update,
    vldmib_f_update,
    vstmib_s_update,
    vstmib_f_update,
    svc,
    vmov_atos,
    vmov_stoa,
    vcvt_f32_f64,
    vcvt_f64_f32,
    vcvt_s32_f64,
    vcvt_s32_f32,
    vcvt_u32_f64,
    vcvt_u32_f32,
    vcvt_f64_s32,
    vcvt_f32_s32,
    vcvt_f64_u32,
    vcvt_f32_u32,
    vcmp_f32,
    vcmp_f64,
    vcmp_f32_zero,
    vcmp_f64_zero,
    vcmpe_f32,
    vcmpe_f64,
    vcmpe_f32_zero,
    vcmpe_f64_zero,
    vabs_f32,
    vabs_f64,
    vmov_f32,
    vmov_f64,
    vsqrt_f32,
    vsqrt_f64,
    vneg_f32,
    vneg_f64,
    vdiv_f32,
    vdiv_f64,
    vmul_f32,
    vmul_f64,
    vadd_f32,
    vadd_f64,
    vsub_f32,
    vsub_f64,
    vnmul_f32,
    vnmul_f64,
    vnmls_f32,
    vnmls_f64,
    vnmla_f32,
    vnmla_f64,
    vmls_f32,
    vmls_f64,
    vmla_f32,
    vmla_f64,
    vmrs_APSR_nzcv_fpscr,
};
/* @AUTOGEN-END@ */

// Describes a class of instructions structurally (read-only data).
struct Opcode {
  const char* name;
  const char* enum_name;
  uint32_t bit_mask;
  uint32_t bit_value;
  uint8_t num_fields;
  OK fields[MAX_OPERANDS];
  uint32_t classes;
  MEM_WIDTH mem_width;
  SR_UPDATE sr_update;
};

// Indexed by ArmINS
extern const Opcode OpcodeTable[];

// Find the Opcode or null for a 32 bit instruction word
extern const Opcode* FindArmOpcode(uint32_t bit_value);

extern const Opcode* FindArmOpcodeForMnemonic(std::string_view s);

// Returns non-zero if successful
extern int32_t InsertOperand(uint32_t data, OK field_kind);

// Decoded representation of the instruction word
struct Ins {
  const Opcode* opcode;
  // number of used entries is ArmOpcode.num_fields
  // branch offset, but this is not ideal since immediates
  // for add/sub/and etc can produce unsigned immediates with
  // high order bit set.
  int32_t operands[MAX_OPERANDS];
  // Relocation info
  std::string_view reloc_symbol;
  elf::RELOC_TYPE_ARM reloc_kind = elf::RELOC_TYPE_ARM::NONE;
  uint8_t reloc_pos;  // index into  operands
  bool is_local_sym = false;
  bool has_reloc() const { return reloc_kind != elf::RELOC_TYPE_ARM::NONE; }

  void clear_reloc() {
    if (has_reloc()) {
      reloc_kind = elf::RELOC_TYPE_ARM::NONE;
      operands[reloc_pos] = 0;
    }
  }
};


// Decode the instruction word `data`
// Returns true if successful
extern bool DecodeIns(Ins* ins, uint32_t data);

extern uint32_t  DecodeRotatedImm(uint32_t data);

extern int32_t SignedIntFromBits(uint32_t data, unsigned n_bits);


// Encode the instruction
// Returns the instruction word. Asserts if unsuccessful
extern uint32_t EncodeIns(const Ins& ins);

const uint32_t kEncodeFailure = 0xffffffff;

// Tries to encode a 32 bit immediate value as a standard
// ARM 12bit shifted immediate.
// If this is successful a 12bit unsigned value is returned.
// Otherwise, kEncodingFailure is returned.
extern uint32_t EncodeRotatedImm(int32_t immediate);


extern uint32_t PatchIns(uint32_t data, unsigned pos, int32_t value);

template <typename Flag>
const char* EnumToString(Flag f);

}  // namespace cwerg::a32

