#!/usr/bin/python3

"""
Convert ARM32 instruction into human readable form suitable to
be processed by an assembler.
"""

import CpuA32.opcode_tab as arm
from Elf import enum_tab

from typing import List, Optional

REG_NAMES_SYSTEMATIC = [
    "r0", "r1", "r2", "r3",
    "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11",
    "r12", "r13", "r14", "r15"]

SHIFT_NAMES_STD = ["lsl", "lsr", "asr", "ror"]


def _Merge(*name_lists):
    out = {}
    for nl in name_lists:
        for n, name in enumerate(nl):
            x = out.get(name)
            if x is None:
                out[name] = n
            else:
                assert x == n, f"conflict {n} vs {x} for {name}"
    return out


ALL_NAMES_MAP = _Merge([p.name for p in arm.PRED],
                       [p.name for p in arm.REG],
                       REG_NAMES_SYSTEMATIC,
                       [p.name for p in arm.DREG],
                       [p.name for p in arm.SREG],
                       [p.name for p in arm.SHIFT])


# render a single operand, e.g. and address like  `[r3, #-116]`
def _RenderOperandStd(opcode, it) -> Optional[str]:
    field_kind, operand = next(it)
    if field_kind is arm.OK.REG_BASE_16_19:
        base = arm.REG(operand).name
        if arm.OPC_FLAG.MULTIPLE in opcode.classes:
            if arm.OPC_FLAG.ADDR_UPDATE in opcode.classes:
                return f"{base}!"
            else:
                return f"{base}"

        offset = ""
        if arm.OPC_FLAG.ADDR_INC in opcode.classes:
            offset = "," + _RenderOperandStd(opcode, it)
        elif arm.OPC_FLAG.ADDR_DEC in opcode.classes:
            offset = _RenderOperandStd(opcode, it)
            if offset.startswith("#"):
                offset = ",#-" + offset[1:]
            else:
                offset = ",-" + offset
        if offset in {",#0", ",#-0"}:
            offset = ""

        if arm.OPC_FLAG.ADDR_UPDATE in opcode.classes:
            if arm.OPC_FLAG.ADDR_POST in opcode.classes:
                return f"[{base}]{offset}"
            elif arm.OPC_FLAG.ADDR_PRE in opcode.classes:
                return f"[{base}{offset}]!"
        else:
            return f"[{base}{offset}]"

    elif field_kind is arm.OK.REG_LINK:
        return None
    elif field_kind in arm.FIELDS_SREG:
        return arm.SREG(operand).name
    elif field_kind in arm.FIELDS_DREG:
        return arm.DREG(operand).name
    elif field_kind in arm.FIELDS_REG:
        return arm.REG(operand).name
    elif field_kind is arm.OK.SHIFT_MODE_ROT:
        shiftee = _RenderOperandStd(opcode, it)
        shift_amount = _RenderOperandStd(opcode, it)
        if shift_amount == "#0":
            return f"{shiftee}"
        return f"{shiftee}, {shift_amount}"
    elif field_kind is arm.OK.SHIFT_MODE_5_6:
        shiftee = _RenderOperandStd(opcode, it)
        shift_amount = _RenderOperandStd(opcode, it)
        if shift_amount == "#0":
            return f"{shiftee}"
        shift_dir = operand
        return f"{shiftee}, {SHIFT_NAMES_STD[shift_dir]} {shift_amount}"
    elif field_kind is arm.OK.SHIFT_MODE_5_6_ADDR:
        shiftee = _RenderOperandStd(opcode, it)
        shift_amount = _RenderOperandStd(opcode, it)
        shift_dir = operand
        if shift_amount == "#0":
            dir = ["", ", lsr #32", ", asr #32", ", rrx"][shift_dir]
            return f"{shiftee}{dir}"
        else:
            return f"{shiftee}, {SHIFT_NAMES_STD[shift_dir]} {shift_amount}"
    elif field_kind in arm.FIELDS_IMM:
        return f"#{operand}"
    elif field_kind is arm.OK.PRED_28_31:
        return None
    elif field_kind is arm.OK.REGLIST_0_15:
        reg_mask = operand
        regs = [arm.REG(x).name for x in range(16) if reg_mask & (1 << x)]
        expr = "{%s}" % (",".join(regs))
        return expr
    elif field_kind == arm.OK.REG_RANGE_0_7 or field_kind == arm.OK.REG_RANGE_1_7:
        reg_count = operand
        start_reg = _RenderOperandStd(opcode, it)
        assert start_reg is not None
        if reg_count == 1:
            return "{" + start_reg + "}"
        kind = start_reg[0]
        reg_num = int(start_reg[1:])
        end_reg = f"{kind}{reg_num + reg_count - 1}"
        return "{" + f"{start_reg}-{end_reg}" + "}"
    assert False, (field_kind, operand)


def _RenderNameStd(opcode: arm.Opcode, pred=None):
    """
    Mimics the name generated by objdump
    """
    name = opcode.name
    if pred is not None:
        if pred != arm.PRED.al:
            name += pred.name
    return name


def RenderInstructionStd(ins: arm.Ins) -> str:
    """Render an instruction more or less as in the ARM manual

    This is provided for cross checking but we do not provide the
     inverse parsing function.

    This is by necessity a bunch of hacks
    """
    pred: Optional[arm.PRED] = None
    for n, f in enumerate(ins.opcode.fields):
        # we skip fPRED_28_31 when we process the operands
        if f is arm.OK.PRED_28_31:
            pred = arm.PRED(ins.operands[n])

    it = zip(ins.opcode.fields, ins.operands)
    ops = []
    try:
        while True:
            ops.append(_RenderOperandStd(ins.opcode, it))
    except StopIteration:
        pass

    # some opcodes do no follow the dst before src order of operands
    if ins.opcode.name in {"str", "vstr", "strh", "strb", "strd",
                           "ldmia", "ldmib", "ldmda", "ldmdb",
                           "vldmia", "vldmib", "vldmda", "vldmdb"}:
        mask = ops.pop(-1)
        ops = [mask] + ops

    if ins.opcode.name == "vmrs":
        ops = ins.opcode.variant.rsplit("_", 1)
    return _RenderNameStd(ins.opcode, pred) + " " + ", ".join([o for o in ops if o])


def _EmitReloc(ins: arm.Ins, pos: int) -> str:
    if ins.reloc_kind == enum_tab.RELOC_TYPE_ARM.JUMP24:
        assert ins.is_local_sym, f"expected local symbol"
        return f"expr:jump24:{ins.reloc_symbol}"
    elif ins.reloc_kind == enum_tab.RELOC_TYPE_ARM.MOVT_ABS:
        loc = "loc_" if ins.is_local_sym else ""
        offset = "" if ins.operands[pos] == 0 else f":{ins.operands[pos]}"
        return f"expr:{loc}movt_abs:{ins.reloc_symbol}{offset}"
    elif ins.reloc_kind == enum_tab.RELOC_TYPE_ARM.MOVW_ABS_NC:
        loc = "loc_" if ins.is_local_sym else ""
        offset = "" if ins.operands[pos] == 0 else f":{ins.operands[pos]}"
        return f"expr:{loc}movw_abs_nc:{ins.reloc_symbol}{offset}"
    elif ins.reloc_kind == enum_tab.RELOC_TYPE_ARM.CALL:
        return f"expr:call:{ins.reloc_symbol}"
    else:
        assert False


def _SymbolizeOperand(field: arm.OK, value: int) -> str:
    if field == arm.OK.PRED_28_31:
        return arm.PRED(value).name
    elif field in arm.FIELDS_REG:
        return arm.REG(value).name
    elif field in arm.FIELDS_DREG:
        return arm.DREG(value).name
    elif field in arm.FIELDS_SREG:
        return arm.SREG(value).name
    elif field in arm.FIELDS_IMM:
        return f"{value}"
    elif field in arm.FIELDS_SHIFT:
        return arm.SHIFT(value).name
    elif field is arm.OK.REG_RANGE_0_7 or field is arm.OK.REG_RANGE_1_7:
        return f"regrange:{value}"
    elif field is arm.OK.REGLIST_0_15:
        return f"reglist:0x{value:04x}"
    else:
        assert False, f"unsupported field {field}"
        return ""


def SymbolizeOperands(ins: arm.Ins) -> List[str]:
    out = []
    for pos, (field, value) in enumerate(zip(ins.opcode.fields, ins.operands)):
        if field in arm.FIELDS_IMM and ins.reloc_kind != 0 and ins.reloc_pos == pos:
            out.append(_EmitReloc(ins, pos))
        else:
            out.append(_SymbolizeOperand(field, value))
    return out


def RenderInstructionSystematic(ins: arm.Ins) -> str:
    return f"{ins.opcode.NameForEnum()} {' '.join(SymbolizeOperands(ins))}"


def UnsymbolizeOperand(o: str) -> int:
    x = ALL_NAMES_MAP.get(o)
    if x is not None:
        return x
    elif ":" in o:
        tag, val = o.split(":")
        return int(val, 0)
    else:
        # must be a number
        return int(o, 0)


_RELOC_KIND_MAP = {
    "abs32": enum_tab.RELOC_TYPE_ARM.ABS32,
    "jump24": enum_tab.RELOC_TYPE_ARM.JUMP24,
    "call": enum_tab.RELOC_TYPE_ARM.CALL,
    "movw_abs_nc": enum_tab.RELOC_TYPE_ARM.MOVW_ABS_NC,
    "movt_abs": enum_tab.RELOC_TYPE_ARM.MOVT_ABS,
}


def InsParse(mnemonic, token: List[str]) -> arm.Ins:
    """Takes textual form of an A32 instruction (in systematic notation) and parses it into a Ins

     * Supports relocatable expressions
     * Adds missing "al" predicate if necessary
     Example input:
     "add_regimm", ["r4", "r4", "lsl", "r0", "0"]
     """
    opcode: arm.Opcode = arm.Opcode.name_to_opcode[mnemonic]
    if opcode.HasPred() and len(token) == len(opcode.fields) - 1:
        token = ["al"] + token
    ins = arm.Ins(opcode)
    for pos, t in enumerate(token):
        if t.startswith("expr:"):
            # expr strings have the form expr:<rel-kind>:<symbol>:<addend>, e.g.:
            #   expr:movw_abs_nc:string_pointers:5
            #   expr:call:putchar
            rel_token = t.split(":")
            if len(rel_token) == 3:
                rel_token.append("0")
            if rel_token[1] == "jump24":
                ins.is_local_sym = True
            if rel_token[1].startswith("loc_"):
                ins.is_local_sym = True
                rel_token[1] = rel_token[1][4:]
            ins.reloc_kind = _RELOC_KIND_MAP[rel_token[1]]
            ins.reloc_pos = pos
            ins.reloc_symbol = rel_token[2]
            ins.operands.append(int(rel_token[3], 0))
        else:
            ins.operands.append(UnsymbolizeOperand(t))
    return ins


if __name__ == "__main__":
    import sys


    def disass(data):
        ins = arm.Disassemble(data)
        if ins.opcode is None:
            print(f"could not disassemble {data:x}")
            return
        print(f"{data:08x}", RenderInstructionStd(ins))
        print("OPCODE", ins.opcode.name, ins.opcode.variant)
        operands_str = SymbolizeOperands(ins)
        for f, o, o_str in zip(ins.opcode.fields, ins.operands, operands_str):
            print(f"    {f.name:19s} {o_str} ({o})")
        print()
        data2 = arm.Assemble(ins)
        assert data == data2
        operands2 = [UnsymbolizeOperand(o) for o in operands_str]
        assert tuple(ins.operands) == tuple(
            operands2), f"{ins.operands} vs {operands2}"
        # opcode.AssembleOperands(operands2)


    for arg_hex_number in sys.argv[1:]:
        disass(int(arg_hex_number, 16))
